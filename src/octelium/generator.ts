import { stringify as stringifyYaml } from "yaml";
import type { OcteliumUser, OcteliumGroup } from "./types";
import type { UserWithGroups, Group } from "../providers/provider";
import type { MappingLoader, ResolvedGroupMapping } from "../mapping/loader";

export interface GeneratorOptions {
  /** Provider name for attrs */
  providerName: string;
}

/**
 * Generate Octelium User manifest
 */
export function generateUser(
  user: UserWithGroups,
  resolvedGroups: Map<string, ResolvedGroupMapping>,
  options: GeneratorOptions
): OcteliumUser {
  // Map IdP groups to Octelium groups
  const octeliumGroups = user.groups
    .map((g) => resolvedGroups.get(g)?.octeliumGroup)
    .filter((g): g is string => g !== undefined);

  return {
    kind: "User",
    metadata: {
      name: sanitizeName(user.username),
    },
    spec: {
      type: "HUMAN",
      email: user.email || undefined,
      groups: octeliumGroups.length > 0 ? octeliumGroups : undefined,
      attrs: {
        source: options.providerName,
        [`${options.providerName}-user-id`]: user.id,
        "managed-by": "idp-octelium-sync",
      },
    },
  };
}

/**
 * Generate Octelium Group manifest
 */
export function generateGroup(
  group: Group,
  resolved: ResolvedGroupMapping,
  options: GeneratorOptions
): OcteliumGroup {
  return {
    kind: "Group",
    metadata: {
      name: sanitizeName(resolved.octeliumGroup),
      displayName: resolved.displayName,
    },
    spec: {
      authorization:
        resolved.policies.length > 0
          ? { policies: resolved.policies }
          : undefined,
      attrs: {
        source: options.providerName,
        [`${options.providerName}-group-id`]: group.id,
        "managed-by": "idp-octelium-sync",
      },
    },
  };
}

/**
 * Generate YAML content for users
 */
export function generateUsersYaml(
  users: UserWithGroups[],
  resolvedGroups: Map<string, ResolvedGroupMapping>,
  options: GeneratorOptions
): string {
  const header = `# AUTO-GENERATED by idp-octelium-sync
# DO NOT EDIT MANUALLY - changes will be overwritten
# Source: ${options.providerName}
# Generated: ${new Date().toISOString()}
`;

  // Sort users by username for deterministic output
  const sortedUsers = [...users].sort((a, b) =>
    a.username.localeCompare(b.username)
  );

  const documents = sortedUsers.map((user) =>
    stringifyYaml(generateUser(user, resolvedGroups, options), {
      lineWidth: 0,
    })
  );

  // Join with --- separator, starting with --- before first document
  return header + "\n---\n" + documents.join("---\n");
}

/**
 * Generate YAML content for groups
 */
export function generateGroupsYaml(
  groups: Group[],
  mappingLoader: MappingLoader,
  options: GeneratorOptions
): { yaml: string; resolvedGroups: Map<string, ResolvedGroupMapping> } {
  const header = `# AUTO-GENERATED by idp-octelium-sync
# DO NOT EDIT MANUALLY - changes will be overwritten
# Source: ${options.providerName}
# Generated: ${new Date().toISOString()}
`;

  const resolvedGroups = new Map<string, ResolvedGroupMapping>();
  const octeliumGroups: OcteliumGroup[] = [];

  // Sort groups by name for deterministic output
  const sortedGroups = [...groups].sort((a, b) => a.name.localeCompare(b.name));

  for (const group of sortedGroups) {
    const resolved = mappingLoader.resolveGroup(group.name);
    if (resolved) {
      resolvedGroups.set(group.name, resolved);
      octeliumGroups.push(generateGroup(group, resolved, options));
    }
  }

  const documents = octeliumGroups.map((g) =>
    stringifyYaml(g, { lineWidth: 0 })
  );

  return {
    yaml: header + "\n---\n" + documents.join("---\n"),
    resolvedGroups,
  };
}

/**
 * Sanitize name to be Kubernetes-compatible
 * - lowercase
 * - replace spaces and underscores with hyphens
 * - remove invalid characters
 */
function sanitizeName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[\s_]+/g, "-")
    .replace(/[^a-z0-9-]/g, "")
    .replace(/^-+|-+$/g, "")
    .substring(0, 63); // max length for K8s names
}
